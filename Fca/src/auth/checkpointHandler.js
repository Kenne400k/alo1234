const logger = require('../utils/logger');
const readline = require('readline');
const https = require('https');
const fs = require('fs');

class CheckpointHandler {
    constructor() {
        this.rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout
        });
    }

    async handleCheckpoint(err, credentials, api, resolve, reject) {
        logger.info('üîí Facebook checkpoint detected!');
        
        if (err.error === 'login-approval') {
            return this.handleLoginApproval(err, credentials, resolve, reject);
        }
        
        if (err.error === 'checkpoint') {
            return this.handleSecurityCheckpoint(err, credentials, resolve, reject);
        }
        
        if (err.continue && typeof err.continue === 'function') {
            return this.handleContinueCallback(err, credentials, resolve, reject);
        }
        
        // Handle other checkpoint types
        if (err.error && err.error.includes('checkpoint')) {
            return this.handleGenericCheckpoint(err, credentials, resolve, reject);
        }
        
        logger.error('Unknown checkpoint type:', err);
        reject(new Error('Lo·∫°i checkpoint kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£'));
    }

    async handleLoginApproval(err, credentials, resolve, reject) {
        logger.warn('üìß Facebook y√™u c·∫ßu x√°c minh thi·∫øt b·ªã');
        logger.info('Ki·ªÉm tra email ho·∫∑c SMS ƒë·ªÉ l·∫•y m√£ x√°c minh');
        
        if (err.continue && typeof err.continue === 'function') {
            logger.info('ƒêang ch·ªù m√£ x√°c minh...');
            
            const code = await this.askForCode('Nh·∫≠p m√£ x√°c minh t·ª´ email/SMS: ');
            
            if (code) {
                try {
                    err.continue(code, (continueErr, api) => {
                        if (continueErr) {
                            logger.error('M√£ x√°c minh sai:', continueErr.message);
                            // Th·ª≠ l·∫°i
                            this.handleLoginApproval(err, credentials, resolve, reject);
                        } else {
                            logger.info('‚úÖ X√°c minh th√†nh c√¥ng!');
                            this.saveSession(api);
                            resolve(api);
                        }
                    });
                } catch (error) {
                    logger.error('L·ªói x·ª≠ l√Ω m√£ x√°c minh:', error.message);
                    reject(error);
                }
            } else {
                reject(new Error('Kh√¥ng c√≥ m√£ x√°c minh'));
            }
        } else {
            // Try alternative method
            this.tryAlternativeVerification(credentials, resolve, reject);
        }
    }

    async handleSecurityCheckpoint(err, credentials, resolve, reject) {
        logger.warn('üõ°Ô∏è Facebook security checkpoint');
        logger.info('ƒêang th·ª≠ bypass checkpoint...');
        
        if (err.continue && typeof err.continue === 'function') {
            // Try to continue with default action
            err.continue((continueErr, api) => {
                if (continueErr) {
                    logger.warn('Checkpoint bypass th·∫•t b·∫°i, c·∫ßn x√°c minh th·ªß c√¥ng');
                    this.handleManualCheckpoint(err, credentials, resolve, reject);
                } else {
                    logger.info('‚úÖ Bypass checkpoint th√†nh c√¥ng!');
                    this.saveSession(api);
                    resolve(api);
                }
            });
        } else {
            this.handleManualCheckpoint(err, credentials, resolve, reject);
        }
    }

    async handleContinueCallback(err, credentials, resolve, reject) {
        logger.info('üîÑ ƒêang x·ª≠ l√Ω callback checkpoint...');
        
        try {
            // First try without any input
            err.continue((continueErr, api) => {
                if (continueErr) {
                    logger.warn('Callback ƒë·∫ßu ti√™n th·∫•t b·∫°i, th·ª≠ ph∆∞∆°ng ph√°p kh√°c...');
                    
                    // Try with empty string
                    err.continue('', (retryErr, retryApi) => {
                        if (retryErr) {
                            logger.warn('C·∫ßn th√¥ng tin b·ªï sung t·ª´ ng∆∞·ªùi d√πng');
                            this.handleInteractiveCheckpoint(err, credentials, resolve, reject);
                        } else {
                            logger.info('‚úÖ Checkpoint resolved!');
                            this.saveSession(retryApi);
                            resolve(retryApi);
                        }
                    });
                } else {
                    logger.info('‚úÖ Checkpoint t·ª± ƒë·ªông resolved!');
                    this.saveSession(api);
                    resolve(api);
                }
            });
        } catch (error) {
            logger.error('L·ªói x·ª≠ l√Ω callback:', error.message);
            this.handleInteractiveCheckpoint(err, credentials, resolve, reject);
        }
    }

    async handleGenericCheckpoint(err, credentials, resolve, reject) {
        logger.warn('üîç Generic checkpoint detected');
        logger.info('Error details:', err.error);
        
        // Try to extract useful information
        if (err.res && err.res.body) {
            const body = err.res.body;
            
            // Look for verification patterns
            if (body.includes('verification') || body.includes('verify')) {
                logger.info('Ph√°t hi·ªán y√™u c·∫ßu x√°c minh');
                return this.handleVerificationCheckpoint(err, credentials, resolve, reject);
            }
            
            if (body.includes('approval') || body.includes('approve')) {
                logger.info('Ph√°t hi·ªán y√™u c·∫ßu ph√™ duy·ªát');
                return this.handleApprovalCheckpoint(err, credentials, resolve, reject);
            }
        }
        
        // Default handling
        this.handleManualCheckpoint(err, credentials, resolve, reject);
    }

    async handleVerificationCheckpoint(err, credentials, resolve, reject) {
        logger.info('üì± X·ª≠ l√Ω verification checkpoint...');
        
        const verificationMethods = [
            () => this.tryPhoneVerification(err, credentials),
            () => this.tryEmailVerification(err, credentials),
            () => this.trySecurityQuestions(err, credentials),
            () => this.tryPhotoVerification(err, credentials)
        ];
        
        for (const method of verificationMethods) {
            try {
                const result = await method();
                if (result) {
                    this.saveSession(result);
                    return resolve(result);
                }
            } catch (methodError) {
                logger.warn('Ph∆∞∆°ng ph√°p verification th·∫•t b·∫°i:', methodError.message);
            }
        }
        
        // If all methods fail
        this.handleManualCheckpoint(err, credentials, resolve, reject);
    }

    async handleApprovalCheckpoint(err, credentials, resolve, reject) {
        logger.info('‚úÖ X·ª≠ l√Ω approval checkpoint...');
        
        // Try automatic approval
        if (err.continue) {
            err.continue((approvalErr, api) => {
                if (approvalErr) {
                    logger.warn('Auto approval th·∫•t b·∫°i');
                    this.handleManualCheckpoint(err, credentials, resolve, reject);
                } else {
                    logger.info('‚úÖ Auto approval th√†nh c√¥ng!');
                    this.saveSession(api);
                    resolve(api);
                }
            });
        } else {
            this.handleManualCheckpoint(err, credentials, resolve, reject);
        }
    }

    async handleInteractiveCheckpoint(err, credentials, resolve, reject) {
        logger.info('üí¨ Interactive checkpoint - c·∫ßn input t·ª´ user');
        
        // Ask user for input
        const userInput = await this.askForInput('Facebook y√™u c·∫ßu th√¥ng tin b·ªï sung. Nh·∫≠p th√¥ng tin: ');
        
        if (err.continue && userInput) {
            err.continue(userInput, (inputErr, api) => {
                if (inputErr) {
                    logger.error('Input kh√¥ng h·ª£p l·ªá:', inputErr.message);
                    // Retry
                    this.handleInteractiveCheckpoint(err, credentials, resolve, reject);
                } else {
                    logger.info('‚úÖ Input ƒë∆∞·ª£c ch·∫•p nh·∫≠n!');
                    this.saveSession(api);
                    resolve(api);
                }
            });
        } else {
            reject(new Error('Kh√¥ng th·ªÉ x·ª≠ l√Ω interactive checkpoint'));
        }
    }

    async handleManualCheckpoint(err, credentials, resolve, reject) {
        logger.warn('‚ö†Ô∏è C·∫ßn x·ª≠ l√Ω checkpoint th·ªß c√¥ng');
        logger.info('H∆∞·ªõng d·∫´n:');
        logger.info('1. M·ªü browser v√† ƒëƒÉng nh·∫≠p Facebook');
        logger.info('2. Ho√†n th√†nh t·∫•t c·∫£ b∆∞·ªõc x√°c minh');
        logger.info('3. Export cookies v√† c·∫≠p nh·∫≠t appstate.json');
        logger.info('4. Kh·ªüi ƒë·ªông l·∫°i ·ª©ng d·ª•ng');
        
        // Try to save current state for later recovery
        if (err.res && err.res.jar) {
            this.saveTemporaryState(err.res.jar);
        }
        
        reject(new Error('C·∫ßn x·ª≠ l√Ω checkpoint th·ªß c√¥ng qua browser'));
    }

    async tryPhoneVerification(err, credentials) {
        logger.info('üìû Th·ª≠ phone verification...');
        // Implementation for phone verification
        return null;
    }

    async tryEmailVerification(err, credentials) {
        logger.info('üìß Th·ª≠ email verification...');
        // Implementation for email verification
        return null;
    }

    async trySecurityQuestions(err, credentials) {
        logger.info('‚ùì Th·ª≠ security questions...');
        // Implementation for security questions
        return null;
    }

    async tryPhotoVerification(err, credentials) {
        logger.info('üì∑ Th·ª≠ photo verification...');
        // Implementation for photo verification
        return null;
    }

    async tryAlternativeVerification(credentials, resolve, reject) {
        logger.info('üîÑ Th·ª≠ ph∆∞∆°ng ph√°p x√°c minh thay th·∫ø...');
        
        // Try re-login with different options
        const fca = require('fca-unofficial');
        const altOptions = {
            logLevel: 'silent',
            forceLogin: false,
            updatePresence: false,
            selfListen: false,
            listenEvents: false,
            userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 17_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1'
        };

        fca({
            email: credentials.email,
            password: credentials.password
        }, altOptions, (altErr, altApi) => {
            if (altErr) {
                logger.error('Alternative verification th·∫•t b·∫°i');
                reject(altErr);
            } else {
                logger.info('‚úÖ Alternative verification th√†nh c√¥ng!');
                this.saveSession(altApi);
                resolve(altApi);
            }
        });
    }

    async askForCode(prompt) {
        return new Promise((resolve) => {
            this.rl.question(prompt, (answer) => {
                resolve(answer.trim());
            });
        });
    }

    async askForInput(prompt) {
        return new Promise((resolve) => {
            this.rl.question(prompt, (answer) => {
                resolve(answer.trim());
            });
        });
    }

    saveSession(api) {
        try {
            if (api && typeof api.getAppState === 'function') {
                const appState = api.getAppState();
                fs.writeFileSync('appstate.json', JSON.stringify(appState, null, 2));
                logger.info('Session ƒë√£ ƒë∆∞·ª£c l∆∞u');
            }
        } catch (error) {
            logger.warn('Kh√¥ng th·ªÉ l∆∞u session:', error.message);
        }
    }

    saveTemporaryState(jar) {
        try {
            // Save temporary state for recovery
            const tempState = {
                cookies: jar.getCookies('https://www.facebook.com'),
                timestamp: Date.now()
            };
            fs.writeFileSync('temp_state.json', JSON.stringify(tempState, null, 2));
            logger.info('Temporary state ƒë√£ ƒë∆∞·ª£c l∆∞u');
        } catch (error) {
            logger.warn('Kh√¥ng th·ªÉ l∆∞u temporary state:', error.message);
        }
    }

    cleanup() {
        if (this.rl) {
            this.rl.close();
        }
    }
}

module.exports = CheckpointHandler;