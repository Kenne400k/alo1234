const fs = require('fs');
const path = require('path');
const fca = require('fca-unofficial');
const logger = require('../utils/logger');
const storage = require('../utils/storage');
const config = require('../config/config');
const errorHandler = require('../handlers/errorHandler');

class LoginManager {
    constructor() {
        this.appstatePath = './appstate.json';
        this.loginOptions = {
            logLevel: 'silent',
            forceLogin: true,
            userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
        };
    }

    async loginWithAppstate() {
        return new Promise((resolve, reject) => {
            if (!fs.existsSync(this.appstatePath)) {
                reject(new Error('Appstate file not found'));
                return;
            }

            let appState;
            try {
                const appStateData = fs.readFileSync(this.appstatePath, 'utf8');
                appState = JSON.parse(appStateData);
                
                if (!Array.isArray(appState) || appState.length === 0) {
                    logger.warn('Appstate file is empty or invalid, will try credential login');
                    reject(new Error('Appstate is empty - credential login required'));
                    return;
                }
                
                // Validate appstate structure
                if (!this.validateAppstate(appState)) {
                    logger.warn('Appstate format is invalid, will try credential login');
                    reject(new Error('Invalid appstate format - credential login required'));
                    return;
                }
            } catch (error) {
                reject(new Error(`Failed to read appstate: ${error.message}`));
                return;
            }

            logger.info('Attempting login with saved appstate...');

            fca({ appState: appState }, this.loginOptions, (err, api) => {
                if (err) {
                    logger.error('Appstate login failed:', err);
                    
                    // Handle specific error cases
                    if (err.error === 'login-approval' || err.error === 'login') {
                        logger.warn('Appstate expired or invalid, removing file');
                        this.removeAppstate();
                        reject(new Error('Appstate expired - credential login required'));
                    } else {
                        reject(errorHandler.handleLoginError(err));
                    }
                    return;
                }

                logger.info('Appstate login successful');
                this.updateAppstate(api);
                resolve(api);
            });
        });
    }

    async loginWithAppPassword(credentials) {
        return new Promise((resolve, reject) => {
            if (!credentials || !credentials.email || !credentials.appPassword) {
                logger.error('Missing app password credentials:', { email: !!credentials?.email, appPassword: !!credentials?.appPassword });
                reject(new Error('Email v√† App Password l√† b·∫Øt bu·ªôc'));
                return;
            }

            logger.info(`ƒêang th·ª≠ ƒëƒÉng nh·∫≠p v·ªõi App Password cho: ${credentials.email}`);

            const loginData = {
                email: credentials.email,
                password: credentials.appPassword
            };

            const appPasswordOptions = {
                logLevel: 'silent',
                forceLogin: true,
                updatePresence: false,
                selfListen: false,
                listenEvents: false,
                userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
            };

            fca(loginData, appPasswordOptions, (err, api) => {
                if (err) {
                    logger.error('App Password login failed:', err);
                    reject(errorHandler.handleLoginError(err));
                    return;
                }

                logger.info('ƒêƒÉng nh·∫≠p v·ªõi App Password th√†nh c√¥ng!');
                this.saveAppstate(api);
                resolve(api);
            });
        });
    }

    async loginWithCookies(cookiesData) {
        return new Promise((resolve, reject) => {
            if (!cookiesData || !Array.isArray(cookiesData) || cookiesData.length === 0) {
                reject(new Error('D·ªØ li·ªáu cookies kh√¥ng h·ª£p l·ªá'));
                return;
            }

            logger.info('ƒêang th·ª≠ ƒëƒÉng nh·∫≠p v·ªõi cookies t·ª´ tr√¨nh duy·ªát...');

            const cookieOptions = {
                logLevel: 'silent',
                forceLogin: false,
                updatePresence: false,
                selfListen: false,
                listenEvents: false,
                userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
            };

            fca({ appState: cookiesData }, cookieOptions, (err, api) => {
                if (err) {
                    logger.error('Cookie login failed:', err);
                    reject(errorHandler.handleLoginError(err));
                    return;
                }

                logger.info('ƒêƒÉng nh·∫≠p v·ªõi cookies th√†nh c√¥ng!');
                this.saveAppstate(api);
                resolve(api);
            });
        });
    }

    async loginWithCredentials(credentials) {
        return new Promise((resolve, reject) => {
            if (!credentials || !credentials.email || !credentials.password) {
                logger.error('Missing credentials:', { email: !!credentials?.email, password: !!credentials?.password });
                reject(new Error('Email and password are required'));
                return;
            }

            logger.info(`Attempting login with credentials for: ${credentials.email}`);

            const loginData = {
                email: credentials.email,
                password: credentials.password
            };

            // Gi·∫£ l·∫≠p h√†nh vi ng∆∞·ªùi d√πng th·∫≠t
            const realUserOptions = this.generateRealUserOptions();

            fca(loginData, realUserOptions, (err, api) => {
                if (err) {
                    logger.error('Credential login failed:', err);
                    
                    // X·ª≠ l√Ω c√°c tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát
                    if (err.error === 'login-approval') {
                        logger.warn('üìß Facebook y√™u c·∫ßu x√°c minh email!');
                        logger.info('üìÆ M√£ x√°c minh ƒë√£ ƒë∆∞·ª£c g·ª≠i ƒë·∫øn email c·ªßa b·∫°n');
                        logger.info('üîó Link x√°c minh: ' + (err.continue || 'Ki·ªÉm tra email'));
                        logger.info('‚è≥ H·ªá th·ªëng ƒëang ch·ªù b·∫°n nh·∫≠p m√£ x√°c minh...');
                        
                        // G·ªçi h√†m x·ª≠ l√Ω email verification
                        this.handleEmailVerification(err, credentials, resolve, reject);
                        return;
                    } else if (err.error === 'checkpoint') {
                        logger.warn('Facebook ph√°t hi·ªán ho·∫°t ƒë·ªông b·∫•t th∆∞·ªùng!');
                        logger.info('ƒêang th·ª≠ x·ª≠ l√Ω checkpoint t·ª± ƒë·ªông...');
                        
                        // Th·ª≠ x·ª≠ l√Ω checkpoint
                        if (err.continue && typeof err.continue === 'function') {
                            logger.info('ƒêang x·ª≠ l√Ω checkpoint...');
                            err.continue((checkpointErr, api) => {
                                if (checkpointErr) {
                                    logger.error('X·ª≠ l√Ω checkpoint th·∫•t b·∫°i:', checkpointErr.message);
                                    reject(new Error('C·∫ßn x√°c minh b·∫£o m·∫≠t - Vui l√≤ng ƒëƒÉng nh·∫≠p qua web tr∆∞·ªõc'));
                                } else {
                                    logger.info('X·ª≠ l√Ω checkpoint th√†nh c√¥ng!');
                                    this.saveAppstate(api);
                                    this.saveCookies(api);
                                    resolve(api);
                                }
                            });
                        } else {
                            reject(new Error('C·∫ßn x√°c minh b·∫£o m·∫≠t - Vui l√≤ng ƒëƒÉng nh·∫≠p qua web tr∆∞·ªõc'));
                        }
                    } else if (err.error === 'Wrong username/password.') {
                        logger.warn('Sai th√¥ng tin ƒëƒÉng nh·∫≠p!');
                        logger.info('ƒêang th·ª≠ c√°c ph∆∞∆°ng ph√°p kh√°c...');
                        
                        // Th·ª≠ delay v√† login l·∫°i v·ªõi headers kh√°c
                        setTimeout(() => {
                            this.retryWithDifferentMethod(credentials, resolve, reject);
                        }, 5000);
                        
                        return;
                    } else {
                        reject(errorHandler.handleLoginError(err));
                    }
                    return;
                }

                logger.info('‚úÖ ƒêƒÉng nh·∫≠p th√†nh c√¥ng!');
                this.saveAppstate(api);
                resolve(api);
            });
        });
    }

    generateRealUserOptions() {
        // Danh s√°ch user agent th·ª±c t·ª´ c√°c tr√¨nh duy·ªát ph·ªï bi·∫øn
        const realUserAgents = [
            // Chrome Windows
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            // Firefox Windows
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:122.0) Gecko/20100101 Firefox/122.0',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0',
            // Chrome Mac
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36',
            // Safari Mac
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.2 Safari/605.1.15',
            // Edge Windows
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36 Edg/121.0.0.0'
        ];

        const randomUserAgent = realUserAgents[Math.floor(Math.random() * realUserAgents.length)];
        
        return {
            logLevel: 'silent',
            forceLogin: false, // Quan tr·ªçng: kh√¥ng force ƒë·ªÉ tr√°nh detection
            updatePresence: false,
            selfListen: false,
            listenEvents: false,
            autoMarkDelivery: false,
            autoMarkRead: false,
            online: false, // Offline mode ƒë·ªÉ √≠t b·ªã ph√°t hi·ªán
            userAgent: randomUserAgent,
            // Th√™m delay t·ª± nhi√™n
            pauseLog: true,
            // Simulation options
            pageID: null
        };
    }

    async retryWithDifferentMethod(credentials, resolve, reject) {
        logger.info('Th·ª≠ v·ªõi ph∆∞∆°ng ph√°p m√¥ ph·ªèng browser th·∫≠t...');
        
        // Delay ƒë·ªÉ m√¥ ph·ªèng th·ªùi gian ng∆∞·ªùi d√πng th·∫≠t
        await new Promise(resolve => setTimeout(resolve, 3000 + Math.random() * 2000));
        
        const browserSimOptions = this.generateBrowserSimulationOptions();
        
        const loginData = {
            email: credentials.email,
            password: credentials.password
        };

        fca(loginData, browserSimOptions, (err, api) => {
            if (err) {
                logger.error('Browser simulation th·∫•t b·∫°i:', err.error || err.message);
                
                // Th·ª≠ v·ªõi mobile simulation
                this.tryMobileSimulation(credentials, resolve, reject);
            } else {
                logger.info('ƒêƒÉng nh·∫≠p th√†nh c√¥ng v·ªõi browser simulation!');
                this.saveAppstate(api);
                this.saveCookies(api);
                resolve(api);
            }
        });
    }

    generateBrowserSimulationOptions() {
        // M√¥ ph·ªèng Chrome tr√™n Windows v·ªõi fingerprint th·∫≠t
        return {
            logLevel: 'silent',
            forceLogin: false,
            updatePresence: false,
            selfListen: false,
            listenEvents: false,
            autoMarkDelivery: false,
            autoMarkRead: false,
            online: false,
            userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36',
            // Th√™m headers m√¥ ph·ªèng browser th·∫≠t
            pageID: null,
            pauseLog: true
        };
    }

    async tryMobileSimulation(credentials, resolve, reject) {
        logger.info('Th·ª≠ v·ªõi mobile browser simulation...');
        
        // Delay kh√°c ƒë·ªÉ m√¥ ph·ªèng retry th·∫≠t
        await new Promise(resolve => setTimeout(resolve, 2000 + Math.random() * 1500));
        
        const mobileOptions = {
            logLevel: 'silent',
            forceLogin: false,
            updatePresence: false,
            selfListen: false,
            listenEvents: false,
            autoMarkDelivery: false,
            autoMarkRead: false,
            online: false,
            // Mobile user agent th·∫≠t
            userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 17_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.2 Mobile/15E148 Safari/604.1',
            pageID: null,
            pauseLog: true
        };

        const loginData = {
            email: credentials.email,
            password: credentials.password
        };

        fca(loginData, mobileOptions, (err, api) => {
            if (err) {
                logger.error('Mobile simulation th·∫•t b·∫°i:', err.error || err.message);
                reject(new Error('T·∫•t c·∫£ ph∆∞∆°ng ph√°p ƒë·ªÅu th·∫•t b·∫°i - c√≥ th·ªÉ c·∫ßn x√°c minh qua browser'));
            } else {
                logger.info('ƒêƒÉng nh·∫≠p th√†nh c√¥ng v·ªõi mobile simulation!');
                this.saveAppstate(api);
                this.saveCookies(api);
                resolve(api);
            }
        });
    }

    handleEmailVerification(err, credentials, resolve, reject) {
        logger.info('ƒêang kh·ªüi t·∫°o qu√° tr√¨nh x√°c minh email...');
        
        // T·∫°o readline interface ƒë·ªÉ nh·∫≠n input t·ª´ user
        const readline = require('readline');
        const rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout
        });

        logger.info('Vui l√≤ng ki·ªÉm tra email v√† nh·∫≠p m√£ x√°c minh:');
        logger.info('Link x√°c minh: ' + (err.continue || 'Ki·ªÉm tra email c·ªßa b·∫°n'));
        
        rl.question('Nh·∫≠p m√£ x√°c minh t·ª´ email: ', (verificationCode) => {
            rl.close();
            
            if (!verificationCode || verificationCode.trim().length === 0) {
                logger.error('M√£ x√°c minh kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng');
                reject(new Error('M√£ x√°c minh kh√¥ng h·ª£p l·ªá'));
                return;
            }

            logger.info('ƒêang x√°c minh m√£: ' + verificationCode.trim());
            
            // S·ª≠ d·ª•ng callback t·ª´ fca-unofficial ƒë·ªÉ x√°c minh
            if (err.continue && typeof err.continue === 'function') {
                // FCA m·ªõi h·ªó tr·ª£ callback cho email verification
                err.continue(verificationCode.trim(), (continueErr, api) => {
                    if (continueErr) {
                        logger.error('X√°c minh th·∫•t b·∫°i:', continueErr.message || continueErr.error);
                        reject(new Error('M√£ x√°c minh kh√¥ng ƒë√∫ng ho·∫∑c ƒë√£ h·∫øt h·∫°n'));
                    } else {
                        logger.info('X√°c minh th√†nh c√¥ng!');
                        this.saveAppstate(api);
                        this.saveCookies(api);
                        resolve(api);
                    }
                });
            } else {
                // Fallback cho phi√™n b·∫£n c≈©
                this.submitVerificationCodeFallback(credentials, verificationCode.trim(), resolve, reject);
            }
        });
    }

    submitVerificationCodeFallback(credentials, code, resolve, reject) {
        logger.info('ƒêang th·ª≠ ph∆∞∆°ng th·ª©c x√°c minh d·ª± ph√≤ng...');
        
        const loginData = {
            email: credentials.email,
            password: credentials.password
        };

        const verificationOptions = {
            logLevel: 'silent',
            forceLogin: true,
            updatePresence: false,
            selfListen: false,
            listenEvents: false,
            userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
        };

        const fca = require('fca-unofficial');
        fca(loginData, verificationOptions, (verifyErr, api) => {
            if (verifyErr) {
                logger.error('X√°c minh d·ª± ph√≤ng th·∫•t b·∫°i:', verifyErr.message || verifyErr.error);
                reject(new Error('Kh√¥ng th·ªÉ x√°c minh m√£. Vui l√≤ng th·ª≠ l·∫°i ho·∫∑c ki·ªÉm tra m√£ x√°c minh.'));
            } else {
                logger.info('X√°c minh d·ª± ph√≤ng th√†nh c√¥ng!');
                this.saveAppstate(api);
                this.saveCookies(api);
                resolve(api);
            }
        });
    }

    submitVerificationCode(continueUrl, code, resolve, reject) {
        const https = require('https');
        const querystring = require('querystring');
        
        logger.info('üîó ƒêang g·ª≠i m√£ x√°c minh ƒë·∫øn Facebook...');
        
        const postData = querystring.stringify({
            'approvals_code': code
        });

        const options = {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Content-Length': Buffer.byteLength(postData),
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
            }
        };

        const req = https.request(continueUrl, options, (res) => {
            let data = '';
            
            res.on('data', (chunk) => {
                data += chunk;
            });
            
            res.on('end', () => {
                if (res.statusCode === 200) {
                    logger.info('‚úÖ M√£ x√°c minh ƒë∆∞·ª£c ch·∫•p nh·∫≠n!');
                    logger.info('üîÑ ƒêang th·ª≠ ƒëƒÉng nh·∫≠p l·∫°i...');
                    
                    // Th·ª≠ ƒëƒÉng nh·∫≠p l·∫°i sau khi x√°c minh
                    this.retryAfterVerification(resolve, reject);
                } else {
                    logger.error('‚ùå X√°c minh th·∫•t b·∫°i. M√£ c√≥ th·ªÉ sai ho·∫∑c ƒë√£ h·∫øt h·∫°n');
                    reject(new Error('M√£ x√°c minh kh√¥ng h·ª£p l·ªá'));
                }
            });
        });

        req.on('error', (error) => {
            logger.error('‚ùå L·ªói khi g·ª≠i m√£ x√°c minh:', error.message);
            reject(new Error('Kh√¥ng th·ªÉ g·ª≠i m√£ x√°c minh'));
        });

        req.write(postData);
        req.end();
    }

    retryAfterVerification(resolve, reject) {
        const config = require('../config/config');
        const credentials = config.getCredentials();
        
        const loginData = {
            email: credentials.email,
            password: credentials.password
        };

        const retryOptions = {
            logLevel: 'silent',
            forceLogin: true,
            updatePresence: false,
            selfListen: false,
            listenEvents: false,
            userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
        };

        const fca = require('fca-unofficial');
        fca(loginData, retryOptions, (err, api) => {
            if (err) {
                logger.error('‚ùå ƒêƒÉng nh·∫≠p sau x√°c minh th·∫•t b·∫°i:', err.message);
                reject(new Error('ƒêƒÉng nh·∫≠p th·∫•t b·∫°i sau x√°c minh'));
            } else {
                logger.info('üéâ ƒêƒÉng nh·∫≠p th√†nh c√¥ng sau x√°c minh!');
                this.saveAppstate(api);
                this.saveCookies(api);
                resolve(api);
            }
        });
    }

    saveCookies(api) {
        try {
            const appState = api.getAppState();
            const fs = require('fs');
            
            // L∆∞u cookies d·ª± tr·ªØ
            fs.writeFileSync('./cookies.json', JSON.stringify(appState, null, 2));
            logger.info('üíæ ƒê√£ l∆∞u cookies d·ª± tr·ªØ v√†o cookies.json');
        } catch (error) {
            logger.error('‚ùå Kh√¥ng th·ªÉ l∆∞u cookies:', error.message);
        }
    }

    saveAppstate(api) {
        try {
            const appState = api.getAppState();
            storage.saveAppstate(appState);
            logger.info('Appstate saved successfully');
        } catch (error) {
            logger.error('Failed to save appstate:', error.message);
        }
    }

    updateAppstate(api) {
        try {
            const appState = api.getAppState();
            storage.updateAppstate(appState);
            logger.info('Appstate updated successfully');
        } catch (error) {
            logger.error('Failed to update appstate:', error.message);
        }
    }

    removeAppstate() {
        try {
            if (fs.existsSync(this.appstatePath)) {
                fs.unlinkSync(this.appstatePath);
                logger.info('Appstate file removed');
            }
        } catch (error) {
            logger.error('Failed to remove appstate:', error.message);
        }
    }

    validateAppstate(appState) {
        if (!Array.isArray(appState)) {
            return false;
        }

        const requiredFields = ['key', 'value', 'domain'];
        return appState.every(cookie => 
            requiredFields.every(field => cookie.hasOwnProperty(field))
        );
    }

    async testConnection(api) {
        return new Promise((resolve) => {
            try {
                api.getFriendsList((err, data) => {
                    if (err) {
                        logger.warn('Connection test failed:', err.message);
                        resolve(false);
                    } else {
                        logger.info('Connection test successful');
                        resolve(true);
                    }
                });
            } catch (error) {
                logger.error('Connection test error:', error.message);
                resolve(false);
            }
        });
    }
}

module.exports = new LoginManager();
